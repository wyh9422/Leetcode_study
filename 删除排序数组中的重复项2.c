int removeDuplicates(int* nums, int numsSize) {
    if (numsSize <= 2) return numsSize; // 如果数组长度小于等于2，直接返回长度

    int front = 1; // 从第二个元素开始

    for (int rear = 2; rear < numsSize; rear++) {
        if (nums[rear] != nums[front] || nums[rear] != nums[front - 1]) {
            front++;
            nums[front] = nums[rear];
        }
    }

    return front + 1;
}

/*基于贪心算法在这个特定的问题中，贪心算法的思想体现在每一步操作都尽可能地保留当前元素（直到它的数量达到2次），同时尽快地移除超过两次出现的元素。

在贪心算法中，决策是基于当前信息，并且一旦作出就不会撤销。在处理有序数组删除重复元素的问题时，您的代码对于每个元素都做出了即时的决定：如果当前元素与前两个不同，则保留它；否则，跳过它。这个决策是基于当前可见的元素，并没有考虑后续元素，这符合贪心算法的特点。

总结一下，您的解决方案：

每次决策都是局部最优的，即尽可能多地保留元素，直到达到允许的最大重复次数（两次）。
由于数组是有序的，这样的局部最优决策也能保证全局最优，即最终结果是所有元素最多出现两次的数组。*/